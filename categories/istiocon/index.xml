<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IstioCon on 爱豆吧！</title>
    <link>https://idouba.com/categories/istiocon/</link>
    <description>Recent content in IstioCon on 爱豆吧！</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>浙ICP备18050493号-1 浙公网安备 33010802006262号</copyright>
    <lastBuildDate>Tue, 26 Sep 2023 15:32:08 +0000</lastBuildDate><atom:link href="https://idouba.com/categories/istiocon/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>IstioCon2023演讲：Cert-manager帮助增强Istio证书管理的安全性和灵活性</title>
      <link>https://idouba.com/istiocon2023-cert-manager-help-enhance-security-and-flexibility-of-istio-certificate-management/</link>
      <pubDate>Tue, 26 Sep 2023 15:32:08 +0000</pubDate>
      
      <guid>https://idouba.com/istiocon2023-cert-manager-help-enhance-security-and-flexibility-of-istio-certificate-management/</guid>
      <description>
        
          
             记录在2023年9月26日在上海IstioCon上发表的技术演讲《cert-manager Help Enhance Security and Flexibility of Istio Certificate Management》
大家好，我是张超盟，来自华为云。今天我分享主题是istio安全的相关内容。 大家使用istio最常见的是非侵入的流量和可观测性能力，如方便的灰度分流策略。实际上，随着使用深入，会感受到istio强大的安全能力。 实际上与其说istio提供了非侵入的认证、授权等安全能力，不如说提供了一个完备的安全模型。我们一般称为零信任安全网络。 在这个安全模型中，证书是非常基础的一块能力。今天的分享中我们将了解istio和一个证书管理服务cert-manager配合提供全面灵活的安全能力。
我是华为云分布式云原生的架构师，从2018年开始也一直在负责华为云应用服务网格的设计开发工作。
演讲的内容包括：
必要的背景Istio零信任安全； Istio安全中证书碰到的问题 和cert-manager给出的解决办法 重点是两个实践：cert-manager提供Istio根证书管理和Ingress-gateway证书管理的的实践。 首先如今天的这次演讲的标题，我们的切入点和上下文是零信任安全。零信任安全的内容很多，我们这里仅介绍本次演讲必要的背景内容。
这是零信任安全的一个比较标准的定义。零信任安全模型描述了一种用于 IT 系统策略、设计和实施的方法。
零信任安全模型背后的主要概念是“从不信任，始终验证”。零信任就是不信任，目标在什么都不信任的环境上提供安全，千万别文字上简单理解成没有信任的安全环境。默认情况下，不应信任用户和设备，即使它们连接到许可的网络，即使它们以前已经过验证。通过建立强身份验证、在授予访问权限之前验证设备合规性，以及确保仅对明确授权的资源进行最小特权访问来实现。
可以看到这和传统理解的安全只是使用防火墙IDS这些在入口处防护，零信任模型里，网络内部和外部都不会信任任何人，网络、人、设备、负载都是zero trust。
零信任安全模型的一个典型实现是这样。可以看到涉及四个大框：
右上角的Resource表示访问的资源，也是零信任安全保护的对象，所有的数据、计算都认为是Resource，对这些资源的访问都要基于零信任网络的原则进行管理。 左上角是资源请求者，或者说客户端。不管这个客户端来自网络外部还是网络内部都是不被信任。 中间的策略执行点PEP来决定哪些访问是信任哪些不信任。PEP基于负载的身份标识、认证客户端的身份、并基于请求属性动态判定对目标资源的访问是否信任。注意这里的判定基于一个独立的连接或者会话，对请求进行评估判定，因此可能出现上一次请求是允许的后面的请求不允许，可能来自一个客户端对统一资源的请求，请求中携带的某个属性变化了，请求就不被允许。 PEP应用的策略都是基于控制面PDP动态生效，就是图下面部分。 以上这个图是不是很容易联想到Istio这张经典的安全的架构图。网格的数据面代理非常适当地扮演了PEP的角色，实现了零信任模型中对PEP的要求。
网格中支持Kubernetes Service account、云平台身份等多种身份标识，并通过证书或编码身份，进行认证；网格数据面代理应用间进行透明的双向认证，同时进行访问通道加密。并且可以自动为网格中的负载签发、续签证书；基于认证的服务身份，结合应用访问内容配置细粒度的授权策略，细粒度地控制资源访问权限，践行零信任安全要求的每会话控制要求和最小访问权限原则；还可以通过访问日志详细记录服务间访问。
并且很重要一点，以上这些能力都是非侵入方式提供，透明地拦截服务间的流量，透明地应用配置的安全策略，应用代码不感知也无需修改，应用部署的下层基础设施无需修改。所以有时我们也说Istio提供了一个零信任的网络基础设施，部署运行在上面的服务负载天然就是满足零信任的要求。
上面图上橘红色圆点标记了Istio安全体现中证书作用的位置。证书是在Istio的零信任安全体系的根基。我们下面展开看下Istio安全体现中证书的几处应用。
前面说过了Istio提供了一套基于负载身份的认证体系。Istio数据面基于负载身份生成负载的证书，并基于负载的证书进行透明的双向认证和通道加密。
主要机制是Istio代理负责维护本Pod内的证书和密钥。Istio代理生成私钥，并基于负载身份，一般是k8s的service account，向Istiod发起证书签名请求CSR（Certificates Signing Request）得到签发的证书和对应的Istio代理上的密钥一起使用。网格代理Envoy上通过SDS获取新的证书，并基于该证书进行身份认证和服务间安全通信。Istio代理负责证书和密钥的定期轮换，当监控到证书过期时重新申请，并向本地Envoy推送新的证书。
虽然负载上证书自动签发和维护，那么签发这些证书的根证书呢？默认情况下Istio提供了一种开箱即用的方式来启用这些安全能力，Istiod会自动创建一个私钥和一个自签名的有效期为10年的证书，存储在cacerts中。Istiod则使用这个根CA为负载签发证书。但在生产环境下这个自签的证书不能满足安全要求，另外每个控制面自签的证书各自负载签发负载证书，也会导致多控制面的场景下，负载间不能互相认证。
另外是网格ingress处的TLS Termination。在Ingress-gateway上配置服务端证书，供源服务，一般是浏览器等客户端认证，并将客户端到网格边界这段TLS的加密流量透明转化为非加密流量向下传递。在Gateway提供客户端认证，避免了入口服务frontend管理证书和与调用方TLS交换的问题。frontend仍然是普通的HTTP协议提供能力，TLS被ingress Gateway卸载或终止掉了。
网格中与Ingress 处的TLS Termination对应的是Egress的TLS Origination。Egress-gateway接收网格内部未加密的流量，根据网格外部服务端的的认证要求进行Simple或双向TLS认证。在Egress-gateway认证网格外部的服务端，避免了出口的微服务自身管理证书和与目标服务TLS交互的问题。backend仍然是普通的HTTP或TCP协议访问外部服务，Egress-gateway代替网格服务发起了TLS请求。
这里列了个表格简单对比了三种模式。
位置看mTLS作用在网格内部，TLS termination和TLS origination分别作用在网格的入口和出口。
mTLS是Istio自动签发证书，自动加载到网格数据面的Sidecar上，Sidecar代替业务透明地完成TLS。TLS termination是客户端程序和Ingress-gateway间进行TLS交换和认证。TLS origination是Egress-gateway和外部目标服务间进行TLS交换和认证。
但有一个共同的特点，都是基于证书的认证，TLS termination和TLS origination是配置的实体证书，需要有证书管理。mTLS虽然负载的证书是由Istio自动签发，但网格的根证书管理还是要解决的问题。包括如何进行证书的管理、续签等。
下面我们总结整理下Istio中证书相关的挑战和需求
首先，避免证书问题引起的服务运行问题，不管是证书过期还是证书配置错误。但是遗憾的是，在实际生产中这却是导致最终业务故障的一类典型问题。另外关于证书最直接的需求是在证书有效期过期前的自动续签。生产中经常是运维人员配置相关告警，在证书快过期前收到告警后，手工去签发和替换证书。如果能有办法在到期前自动续签，可以减少这部分人工负担，并可避免人工操作引入的失误。
可以有一种方式可以灵活方便地配置证书的相关属性，包括有效期、dns域名等。最好是能支持多种证书签发者，包括公有CA和私有CA等。另外一个是最好能和云原生有结合，方便云原生的应用或者平台使用证书。
附： 演讲材料(官方Slides) 官方Sched主页 
          
          
        
      </description>
    </item>
    
    <item>
      <title>SpringClod到Istio最佳实践</title>
      <link>https://idouba.com/best-practice-from-spring-cloud-to-istio/</link>
      <pubDate>Tue, 23 Feb 2021 15:32:08 +0000</pubDate>
      
      <guid>https://idouba.com/best-practice-from-spring-cloud-to-istio/</guid>
      <description>
        
          
            记录在北京时间2月23日，在全球首届社区峰会IstioCon 2021中，发表的《Best practice:from Spring Cloud to Istio》技术演讲。回答经常被客户和同事们问到的一个问题，SpringCloud和Istio的关系，如何演进。
以下为演讲全文: 大家好，我是来自华为云的工程师。很荣幸有机会和大家分享Istio在生产中使用的实际案例。
华为云应用服务网格从2018年在公有云上线， 作为全球最早的几个网格服务之一，经历和见证了从早期对网格的了解、尝试到当前大规模使用的过程。服务的客户越来越多，场景也越来越复杂。这其中的通用功能作为feature大都贡献到Istio社区，解决方案层面的实践也希望通过这样的机会和大家交流。
本次我选取的主题是Spring Cloud to Istio。来自我们客户的Spring cloud的项目和Istio的结合与迁移案例。
演讲主要包含四部分的内容： 1）背景介绍
2）使用Spring cloud微服务框架遇到的问题
3）解决方案
4）通过示例来描述方案的实践细节
背景介绍 还是以微服务为切入点，微服务的诸多优势非常明显，但相应给整个系统带来的复杂度也非常显著。单体的系统变成了分布式后，网络问题，服务如何找到并访问到对端的服务发现问题，网络访问的容错保护问题等。连当年最简单的通过日志中的调用栈就能实现的问题定位，微服务化后必须要通过分布式调用链才能支持。怎样解决微服务带来的这些挑战？
微服务SDK曾经是一个常用的解决方案。将微服务化后通用的能力封装在一个开发框架中，开发者使用这个框架开发写自己的业务代码，生成的微服务自然就内置了这些能力。在很长的一段时间内，这种形态是微服务治理的标配，以至于初学者以为只有这些SDK才是微服务。
服务网格则通过另一种形态提供治理能力。不同于SDK方式，服务治理的能力在一个独立的代理进程中提供，完全和开发解耦。虽然从图上看两者差异非常小，后面我们将会从架构和实际案例来分析两者在设计理念上的差异，来体会前者是一个开发框架，而后者是一个基础设施。
SDK形态中Spring cloud是最有影响力的代表项目。Spring cloud提供了构建分布式应用的开发工具集，如列表所示。其中被大部分开发者熟知的是微服务相关项目，如：服务注册发现eureka、配置管理 config、负载均衡ribbon、熔断容错Hystrix、调用链埋点sleuth、网关zuul或Spring cloud gateway等项目。在本次分享中提到的Spring cloud也特指Spring cloud的微服务开发套件。
而网格形态中，最有影响力的项目当属Istio。Istio的这张架构图在这次演讲中会高频出现。作为本次分享的背景，我们只要知道架构上由控制面和数据面组成，控制面管理网格里面的服务和对服务配置的各种规则。数据面上每个服务间的出流量和入流量都会被和服务同POD的数据面代理拦截和执行流量管理的动作。
除了架构外，作为背景的另外一个部分，我们挑两个基础功能稍微打开看下两者的设计和实现上的相同和不同。首先是服务发现和负载均衡。
左边是Spring cloud，所有的微服务都会先注册中心，一般是Eureka进行服务注册，然后在服务访问时，consumer去注册中心进行服务发现得到待访问的目标服务的实例列表，使用客户端负载均衡ribbon选择一个服务实例发起访问。
右边Istio不需要服务注册的过程，只需要从运行平台k8s中获取服务和实例的关系，在服务访问时，数据面代理Envoy拦截到流量，选择一个目标实例发送请求。可以看到都是基于服务发现数据进行客户端负载均衡，差别是服务发现数据来源不同，负载均衡的执行体不同。
下面比较下熔断：
左边为经典的Hystrix的状态迁移图。一段时间内实例连续的错误次数超过阈值则进入熔断开启状态，不接受请求；隔离一段时间后，会从熔断状态迁移到半熔断状态，如果正常则进入熔断关闭状态，可以接收请求；如果不正常则还是进入熔断开启状态。
Istio中虽然没有显示的提供这样一个状态图，但是大家熟悉Istio规则和行为应该会发现，Istio中OutlierDection的阈值规则也都是这样设计的。两者的不同是Spring cloud的熔断是在SDK中Hystrix执行，Istio中是数据面proxy执行。Hystrix因为在业务代码中，允许用户通过编程做一些控制。
以上分析可以看到服务发现、负载均衡和熔断，能力和机制都是类似的。如果忽略图上的某些细节，粗的看框图模型都是完全一样的，对比表格中也一般只有一项就是执行位置不同，这一点不同在实际应用中带来非常大的差异。
使用Spring cloud微服务框架遇到的问题 本次演讲的重点是实践。以下是我们客户找到我们TOP的几个的问题，剖析下用户使用传统微服务框架碰到了哪些问题，这些大部分也是他们选择网格的最大动力。
1）多语言问题 在企业应用开发下，一个业务使用统一的开发框架是非常合理常见的，很多开发团队为了提升效率，经常还会维护有自己公司或者团队的通用开发框架。当然因为大部分业务系统都是基于Java开发，所以Spring cloud开发框架，或者衍生于Spring cloud的各种开发框架使用的尤其广泛。
但是在云原生场景下，业务一般更加复杂多样，特别是涉及到很多即存的老系统。我们不能要求为了微服务化将在用的一组成熟服务用Spring cloud重写下。用户非常希望有一种方式不重写原来的系统也能对其进行应用层服务访问管理。
2）将Spring cloud的微服务运行在K8s上会有很大的概率出现服务发现不及时 前面介绍过Spring cloud服务发现是基于各个微服务先向注册中心进行服务注册的数据来实现的，在传统Spring cloud场景下，当微服务部署在VM上，服务动态变化要求没有那么高，顶多个别实例运行不正常，通过服务发现的健康检查就足够了。但是在k8s场景下，服务实例动态迁移是非常正常场景。如图示，producer的某个Pod已经从一个节点迁移到另外一个节点了，这时需要新的pod2的producer实例向eureka注册，老实例Pod1要去注册。
如果该情况频繁发生，会出现注册中心数据维护不及时，导致服务发现和负载均衡到旧的实例pod1上，从而引起访问失败的情况。
3）升级所有应用以应对服务管理需求变化 第三个问题是一个比较典型的问题。客户有一个公共团队专门维护了一套基于Spring cloud的自有开发框架，在每次升级开发框架时，不得不求着业务团队来升级自己的服务。经常会SDK自身修改测试工作量不大，但却要制定很长周期的升级计划，来对上千个基于这个SDK开发的服务分组重新编译，打包，升级，而且经常要陪着业务团队在夜间变更。业务团队因为自身没有什么改动，考虑到这个升级带来的工作量和线上风险，一般也没有什么动力。
4）从单体式架构向微服务架构迁移 这是一个比较普遍的问题，就是渐进的微服务化。马丁福勒在著名的文章单体到微服务的拆分中（https://martinfowler.com/articles/break-monolith-into-microservices.html ）也提到了对渐进微服务化的倡议，如何能从业务上将一个大的业务分割，解耦，然后逐步微服务化。马丁福勒强调 “解耦的是业务能力不是代码” ，大神将代码的解耦留给了开发者。
但是站在开发者的角度讲渐进的微服务不是一个容易的事情。以基于Spring cloud框架进行微服务开发为例，为了所有的微服务间进行统一的服务发现、负载均衡，消费和执行同样的治理策略，必须要求所有的微服务基于同样的，甚至是统一版本的SDK来开发。
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
